 \section{Test Results}
 
Preliminary Testing: Autonomous operations were performed in three steps, beginning with code written for the light source detection procedure. Coding the light detection algorithm meant reading values from both light sensors mounted about 2 inches apart on the front of the chassis and pointed slightly inward so their fields of vision overlapped, and adjusting course direction based on the differences in readings. To first detect the light, DynaSaRR first rotated slowly clockwise until a signal above the threshold was acquired. This was intended to make the SaRR better suited to real-world performace, as it would need to detect the light source regardless of its position. Under these test conditions, however, the light source was placed to the right the chute exit. Thus, once DynaSaRR recognized it had exited the chute using the side-facing proximity sensors, it began to turn clockwise in search of the light source. Once the robot acquired the light signal and determined that it was facing directly into the light (the two light sensors read approximately the same value), it began to drive forward towards the basket. This command continued until the value read by one light sensor differed significantly from the other. Once this difference was been detected, the robot adjusted it course by turning slightly towards the dimmer light sensor until the values read were similar again. This process repeated until DynaSaRR's front-mounted proximity sensor detected the delivery basket, and notified DynaSaRR to stop within approximately 6" of the bin. At that point, the medkit motor arm was is activated and the medkit was dropped into the bin. Having completed its delivery, the robot paused and then backed up several inches, releasing the medkit fully. Programming this operation presented several challenges, particularly with the variation in results while testing. It took several runs to determine how much voltage should be sent to each motor in order for turns to be made consistently. Too little, and the robot wouldn't turn, but too much and the robot would overshoot the column of light and oscillate back and forth trying to realign itself. The key turned out to be a medium voltage for a short duration of time. This enabled the bot to turn consistently but with only minor adjustments to direction. Unfortunately, the robot's performance was not consistent over time, as the draining batteries resulted in the same amount of voltage to the motor producing a much smaller turn, so the code was designed to run successfully at close to full battery charge. The final step of the code also required tuning, because it required DynaSaRR to stop at the same distance (within 1 inch) every time. The robot needed to be both perfectly aligned and perfectly distanced from the wall for the medkit arm to successfully drop off the medkit. This meant slowly fine tuning the threshold value for the front proximity sensor. From a test distance of 30 feet, it took DynaSaRR an average of 29 seconds to deliver the medkit in testing.

The next challenge, also noted by a milestone, was autonomous navigation of the chute. Coding this portion was not as difficult as the deposition step once the turn command was tested extensively in the first coding portion. After breaching the wall, DynaSaRR would enter the chute. Chute detection began when both side-mounted proximity sensors registered sharp change in distance. Once the robot entered the chute, it slowed slightly and rapidly updated its readings for both proximity sensors. As it approached a corner or turn, the difference between to the two sensors triggered it to turn away from the closer wall until the sensors began reading similar numbers again. Interestingly, the sensors were originally mounted at about a 45 degree angle facing forward in order to preemptively detect turns and adjust before reaching them. However, the algorithm worked much more consistently when keeping the sensors facing fully sideways, perpendicular to the direction of driving. Once the sensors were mounted this way, DynaSaRR successfully navigated the chute on its first test run, and the results were found to be repeatable until battery drainage caused the course adjustments to fail. On test day, chute navigation took approximately 25 seconds. 

Last, but certainly not least, was the autonomous wall traversal. This operation proved especially difficult because it required precise timing of both the driving wheels and lifting arms to propel the rather heavy robot over the wall. Open-loop wall breaching was immediately and consistently successful without the addition of the medkit arm retrieval mechanism or the medkit itself. However, the additional weight of the medkit and arm shifted the center of gravity backward, making open-loop navigation over the wall less consistent. After adding bolts to the lifting arms, open-loop traversal became reliable again. 

When testing autonomous wall breaching, the SaRRchaeologists found that it was important to keep both batteries fresh, and to periodically tighten the lifting arm set screws. Repeated attempts--both successes and failures--put a lot of stress on the chassis, even with the shock-absorbing springs on the front wheels, but no major damage was sustained despite several inversions and hard landings. To trigger the three-step wall breaching code, the front proximity sensor first detected that the robot was within a few inches of the first step. Then, the lifting arms rotated to lift the front wheels off the ground and, with the back wheels driving, placed the front wheels atop the first step. This command was repeated to prop the robot up onto the top of the wall. During testing, pauses were inserted in between each separate motion to ensure breaching the wall was not a function of momentum, which could be inconsistent. With the front wheels over the top of the wall and the back wheels still on the ground, full power was given to the lifting arms and rear wheels to pull the robot over the wall. By tweaking and tuning the code, success was eventually achieved in breaching the wall. However, results were inconsistent: the code would not always work the same way each time, and every few attempts, the robot would end up flipping over completely, either before breaching the wall or after landing. Despite many test runs, no mechanical or structural damage was obtained, which proved that the SaRRchaeologists had achieved their goal of making DynaSaRR thoroughly robust, particularly with respect to vertical drops. In the end, wall breaching took approximately 15 seconds to complete.

On the day of competition, DynaSaRR did not perform as well as expected due to some minor problems with constants in autonomous code, energy inefficiencies, and testing conditions that were slightly different than expected. The light sensing code threshold for the difference between the two sensor readings was slightly too large, making it unlikely that the SaRR would correctly track the light unless conditions of ambient light were nearly ideal and the light sensors in use were perfectly oriented. Along with this error, one of the light sensors in use was showing inconsistent readings the night before and just after testing, making the code unlikely to work as it did previously. In particular, the inconsistent readings resulted in the code believing that the robot was always to the left of the light column and therefore turning to the right to reacquire the signal. However, since the robot was already to the right of the ideal path, this resulted in DynaSaRR losing the light signal completely and beginning to spin in an attempt to reacquire it. Additionally, the SaRR very quickly lost ideal operating power, as the drill batteries in use were fairly drained after only one attempt at the course. This greatly reduced the chance of conquering the autonomous portions on subsequent trials, as the constants in use were designed for a battery at full power. Furthermore, this resulted in a failure to successfully breach the wall: in its first attempt with full power, DynaSaRR breached the wall, but was given too much power and flipped over on the dismount. In subsequent attempts, the power provided to the motor was reduced to avoid flipping, but since the batteries had been partially drained, these adjustments caused the robot to fail to pull itself over the final step of the wall. In further tests, the batteries were so drained that the robot was no longer able to breach the wall, even in open-loop mode. Lastly, the conditions of the lab in which the competition was conducted were not the same as those in which tests were completed throughout the semester, leaving the team to work on fine-tuning code in the last few days before the competition, without being able to test code for long periods of time without triggering reliability issues due to draining batteries. While the team believed most problems had been solved, some issues regarding inconsistencies on the floor and reflections around the room were unavoidable, and the SaRRchaeologists were not ultimately able to overcome these challenges within the time frame of the demonstration.

Overall, the physical capabilities of the robot did not limit the performance on competition day. Instead, the performance was limited primarily by code that may not have been robust enough to adjust to new circumstances, as well as problems caused by the draining batteries. 

\newpage
 
